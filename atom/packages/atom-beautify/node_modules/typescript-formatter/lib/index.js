/// <reference path="../typings/node/node.d.ts" />
/// <reference path="../node_modules/typescript/bin/typescript.d.ts" />
"use strict";
var formatter = require("./formatter");
var utils = require("./utils");
var fs = require("fs");
var base = require("./provider/base");
var editorconfig = require("./provider/editorconfig");
var tslintjson = require("./provider/tslintjson");
function processFiles(files, opts) {
    "use strict";
    var resultMap = {};
    var promises = files.map(function (fileName) {
        if (!fs.existsSync(fileName)) {
            console.error(fileName + " is not exists. process abort.");
            process.exit(1);
            return;
        }
        var content = fs.readFileSync(fileName).toString();
        return processString(fileName, content, opts);
    });
    return Promise.all(promises).then(function (resultList) {
        resultList.forEach(function (result) {
            resultMap[result.fileName] = result;
        });
        return resultMap;
    });
}
exports.processFiles = processFiles;
function processStream(fileName, input, opts) {
    "use strict";
    input.setEncoding("utf8");
    var promise = new Promise(function (resolve, reject) {
        var fragment = "";
        input.on("data", function (chunk) {
            if (chunk === "") {
                return;
            }
            fragment += chunk;
        });
        input.on("end", function () {
            resolve(fragment);
        });
    });
    return promise.then(function (content) { return processString(fileName, content, opts); });
}
exports.processStream = processStream;
function processString(fileName, content, opts) {
    "use strict";
    var options = utils.createDefaultFormatCodeOptions();
    var optGenPromises = [];
    if (opts.tsfmt) {
        optGenPromises.push(base.makeFormatCodeOptions(fileName, options));
    }
    if (opts.editorconfig) {
        optGenPromises.push(editorconfig.makeFormatCodeOptions(fileName, options));
    }
    if (opts.tslint) {
        optGenPromises.push(tslintjson.makeFormatCodeOptions(fileName, options));
    }
    return Promise
        .all(optGenPromises)
        .then(function () {
        var formattedCode = formatter(content, options);
        // TODO replace newline code. NewLineCharacter params affect to only "new" newline. maybe.
        if (opts && opts.replace) {
            if (content !== formattedCode) {
                fs.writeFileSync(fileName, formattedCode);
                console.log("replaced " + fileName);
            }
        }
        else if (opts && !opts.dryRun) {
            console.log(formattedCode);
        }
        var result = {
            fileName: fileName,
            options: options,
            src: content,
            dest: formattedCode
        };
        return Promise.resolve(result);
    });
}
exports.processString = processString;
