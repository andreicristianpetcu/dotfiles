// Generated by CoffeeScript 1.8.0
(function() {
  var CODE_REGEX, Entities, IMG_REGEX, LINK_REGEX, delimitCode, fixHeaders, fm, formatTable, htmlEntities, indent, longestStringInArray, marked, nestContainingTokens, nestingEndTokens, nestingStartTokens, pad, preprocessAST, prettyInlineMarkdown, yaml,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  marked = require('marked');

  Entities = require('html-entities').AllHtmlEntities;

  indent = require('indent');

  pad = require('pad');

  yaml = require('js-yaml');

  fm = require('front-matter');

  htmlEntities = new Entities();

  function stringRepeat(x, n) {
  var s = '';
  for (;;) {
    if (n & 1) s += x;
    n >>= 1;
    if (n) x += x;
    else break;
  }
  return s;
};


  /**
   * Find the length of the longest string in an array
   * @param {String[]} array Array of strings
   */

  longestStringInArray = function(array) {
    var len, longest, str, _i, _len;
    longest = 0;
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      str = array[_i];
      len = str.length;
      if (len > longest) {
        longest = len;
      }
    }
    return longest;
  };


  /**
   * Wrap code with delimiters
   * @param {[type]} code
   * @param {[type]} delimiter The delimiter to start with, additional backticks
     will be added if needed; like if the code contains a sequence of backticks
     that would end the code block prematurely.
   */

  delimitCode = function(code, delimiter) {
    while (RegExp("([^`]|^)" + delimiter + "([^`]|$)").test(code)) {
      delimiter += '`';
    }
    if (code[0] === '`') {
      code = ' ' + code;
    }
    if (code.slice(-1) === '`') {
      code += ' ';
    }
    return delimiter + code + delimiter;
  };

  IMG_REGEX = /<img src="([^"]*)"(?: alt="([^"]*)")?(?: title="([^"]*)")?>/g;

  LINK_REGEX = /<a href="([^"]*)"(?: title="([^"]*)")?>([^<]*)<\/a>/g;

  CODE_REGEX = /<code>([^<]+)<\/code>/g;

  prettyInlineMarkdown = function(token) {
    token.text = marked.inlineLexer(token.text, token.links || {}).replace(/\u2014/g, '--').replace(/\u2018|\u2019/g, '\'').replace(/\u201c|\u201d/g, '"').replace(/\u2026/g, '...').replace(/<\/?strong>/g, '**').replace(/<\/?em>/g, '_').replace(/<\/?del>/g, '~~').replace(CODE_REGEX, function(m, code) {
      return delimitCode(code, '`');
    }).replace(IMG_REGEX, function(m, url, alt, title) {
      if (url == null) {
        url = '';
      }
      if (alt == null) {
        alt = '';
      }
      if (title != null) {
        url += " \"" + (title.replace(/\\|"/g, function(m) {
          return "\\" + m;
        })) + "\"";
      }
      return "![" + alt + "](" + url + ")";
    }).replace(LINK_REGEX, function(m, url, title, text) {
      if (url == null) {
        url = '';
      }
      if (text == null) {
        text = '';
      }
      if (title != null) {
        url += " \"" + (title.replace(/\\|"/g, function(m) {
          return "\\" + m;
        })) + "\"";
      }
      return "[" + text + "](" + url + ")";
    });
    token.text = htmlEntities.decode(token.text);
    return token;
  };

  nestingStartTokens = ['list_item_start', 'blockquote_start', 'loose_item_start'];

  nestingEndTokens = ['list_item_end', 'blockquote_end', 'loose_item_end'];

  nestContainingTokens = ['list_item', 'blockquote', 'loose_item'];

  preprocessAST = function(ast) {
    var currentToken, e, i, nestingLevel, orderedList, orderedListItemNumber, out, subAST, token, tokenIndex, _i, _len, _ref, _ref1, _ref2, _ref3;
    i = 0;
    out = [];
    orderedList = false;
    while (i < ast.length) {
      currentToken = ast[i];
      if (currentToken.type === 'list_start') {
        orderedListItemNumber = 0;
        orderedList = currentToken.ordered;
      } else if (_ref = currentToken.type, __indexOf.call(nestingStartTokens, _ref) >= 0) {
        tokenIndex = nestingStartTokens.indexOf(currentToken.type);
        currentToken.type = nestContainingTokens[tokenIndex];
        i++;
        nestingLevel = 1;
        subAST = [];
        while (true) {
          if (_ref1 = ast[i].type, __indexOf.call(nestingEndTokens, _ref1) >= 0) {
            nestingLevel--;
          } else if (_ref2 = ast[i].type, __indexOf.call(nestingStartTokens, _ref2) >= 0) {
            nestingLevel++;
          }
          if (nestingLevel === 0) {
            break;
          }
          subAST.push(ast[i]);
          i++;
        }
        e = 0;
        _ref3 = preprocessAST(subAST);
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          token = _ref3[_i];
          if (token.nesting == null) {
            token.nesting = [];
          }
          if (token.indent == null) {
            token.indent = '';
          }
          token.nesting.push(currentToken.type);
          if (token.nesting !== [] && token.nesting.length > 1) {
            token.indent = '  ' + token.indent;
          } else if (currentToken.type === 'blockquote') {
            token.indent += '> ';
          } else if (currentToken.type === 'list_item') {
            token.type = 'list_item';
            if (orderedList) {
              orderedListItemNumber++;
              token.indent += "" + orderedListItemNumber + ". ";
            } else {
              token.indent += '- ';
            }
          } else if (e === 0 && token.type === 'text' && currentToken.type === 'loose_item') {
            token.type = 'list_item';
            token.indent += '- ';
          } else {
            token.indent = '  ' + token.indent;
          }
          if (token.type === 'text' && currentToken.type === 'loose_item') {
            token.type = 'paragraph';
          }
          e++;
          out.push(token);
        }
      } else {
        out.push(currentToken);
      }
      i++;
    }
    return out;
  };


  /**
   * Some people accidently skip levels in their headers (like jumping from h1 to
   * h3), which screws up things like tables of contents. This function fixes
   * that.
  
   * The algorithm assumes that relations between nearby headers are correct and
   * will try to preserve them. For example, "h1, h3, h3" becomes "h1, h2, h2"
   * rather than "h1, h2, h3".
   */

  fixHeaders = function(ast, ensureFirstHeaderIsH1) {
    var e, gap, i, lastHeaderDepth, parentDepth, rootDepth, _ref;
    i = 0;
    lastHeaderDepth = 0;
    if (!ensureFirstHeaderIsH1) {
      e = 0;
      while (e < ast.length) {
        if (ast[e].type !== 'heading') {
          e++;
        } else {
          lastHeaderDepth = ast[e].depth - 1;
          break;
        }
      }
    }
    rootDepth = lastHeaderDepth + 1;
    while (i < ast.length) {
      if (ast[i].type !== 'heading') {

      } else if ((rootDepth <= (_ref = ast[i].depth) && _ref <= lastHeaderDepth + 1)) {
        lastHeaderDepth = ast[i].depth;
      } else {
        e = i;
        if (ast[i].depth <= rootDepth) {
          gap = ast[i].depth - rootDepth;
        } else {
          gap = ast[i].depth - (lastHeaderDepth + 1);
        }
        parentDepth = ast[i].depth;
        while (e < ast.length) {
          if (ast[e].type !== 'heading') {

          } else if (ast[e].depth >= parentDepth) {
            ast[e].depth -= gap;
          } else {
            break;
          }
          e++;
        }
        continue;
      }
      i++;
    }
    return ast;
  };

  formatTable = function(token) {
    var alignment, col, colWidth, i, j, out, row, _i, _j, _k, _l, _len, _len1, _m, _ref, _ref1, _ref2, _ref3, _ref4;
    out = [];
    for (i = _i = 0, _ref = token.header.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      col = [token.header[i]];
      for (j = _j = 0, _ref1 = token.cells.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
        token.cells[j][i] = (token.cells[j][i] != null ? token.cells[j][i].trim() : '');
        col.push(token.cells[j][i]);
      }
      colWidth = longestStringInArray(col);
      token.header[i] = pad(token.header[i], colWidth);
      alignment = token.align[i];
      token.align[i] = ((function() {
        switch (alignment) {
          case null:
            return pad('', colWidth, '-');
          case 'left':
            return ':' + pad('', colWidth - 1, '-');
          case 'center':
            return ':' + pad('', colWidth - 2, '-') + ':';
          case 'right':
            return pad('', colWidth - 1, '-') + ':';
        }
      })());
      for (j = _k = 0, _ref2 = token.cells.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; j = 0 <= _ref2 ? ++_k : --_k) {
        token.cells[j][i] = (alignment === 'right' ? pad(colWidth, token.cells[j][i]) : pad(token.cells[j][i], colWidth));
      }
    }
    if (token.header.length > 1) {
      out.push(token.header.join(' | ').trimRight());
      out.push(token.align.join(' | '));
      _ref3 = token.cells;
      for (_l = 0, _len = _ref3.length; _l < _len; _l++) {
        row = _ref3[_l];
        out.push(row.join(' | ').trimRight());
      }
    } else {
      out.push('| ' + token.header[0].trimRight());
      out.push('| ' + token.align[0]);
      _ref4 = token.cells;
      for (_m = 0, _len1 = _ref4.length; _m < _len1; _m++) {
        row = _ref4[_m];
        out.push('| ' + row[0].trimRight());
      }
    }
    out.push('');
    return out;
  };

  module.exports = function(dirtyMarkdown, options) {
    var ast, content, id, line, link, links, optionalTitle, out, previousToken, token, _i, _j, _len, _len1, _ref, _ref1, _ref2;
    if (options == null) {
      options = {};
    }
    if (options.ensureFirstHeaderIsH1 == null) {
      options.ensureFirstHeaderIsH1 = true;
    }
    out = [];
    content = fm(dirtyMarkdown);
    if (Object.keys(content.attributes).length !== 0) {
      out.push('---', yaml.safeDump(content.attributes).trim(), '---\n');
    }
    ast = marked.lexer(content.body);
    links = ast.links;
    previousToken = void 0;
    ast = ast.filter(function(token) {
      var _ref;
      return (_ref = token.type) !== 'space' && _ref !== 'list_end';
    });
    ast = preprocessAST(ast);
    ast = fixHeaders(ast, options.ensureFirstHeaderIsH1);
    for (_i = 0, _len = ast.length; _i < _len; _i++) {
      token = ast[_i];
      if (token.indent == null) {
        token.indent = '';
      }
      if (token.nesting == null) {
        token.nesting = [];
      }
      switch (token.type) {
        case 'heading':
          if ((previousToken != null) && previousToken.type !== 'heading') {
            out.push('');
          }
          out.push(stringRepeat('#', token.depth) + ' ' + token.text);
          break;
        case 'paragraph':
          if ((_ref = previousToken != null ? previousToken.type : void 0) === 'paragraph' || _ref === 'list_item' || _ref === 'text') {
            out.push('');
          }
          out.push(token.indent + prettyInlineMarkdown(token).text.replace(/\n/g, ' '));
          break;
        case 'text':
        case 'list_item':
          if ((previousToken != null) && token.type === 'list_item' && (previousToken.nesting.length > token.nesting.length || (previousToken.type === 'paragraph' && ((_ref1 = previousToken.nesting) != null ? _ref1.length : void 0) >= token.nesting.length))) {
            out.push('');
          }
          out.push(token.indent + prettyInlineMarkdown(token).text);
          break;
        case 'code':
          if (token.lang == null) {
            token.lang = '';
          }
          token.text = delimitCode("" + token.lang + "\n" + token.text + "\n", '```');
          out.push('', indent(token.text, token.indent), '');
          break;
        case 'table':
          if (previousToken != null) {
            out.push('');
          }
          out.push.apply(out, formatTable(token));
          break;
        case 'hr':
          if (previousToken != null) {
            out.push('');
          }
          out.push(token.indent + stringRepeat('-', 80), '');
          break;
        case 'html':
          _ref2 = token.text.split('\n');
          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
            line = _ref2[_j];
            out.push(line);
          }
          break;
        default:
          throw new Error("Unknown Token: " + token.type);
      }
      previousToken = token;
    }
    if (Object.keys(links).length > 0) {
      out.push('');
    }
    for (id in links) {
      link = links[id];
      optionalTitle = link.title ? " \"" + link.title + "\"" : '';
      out.push("[" + id + "]: " + link.href + optionalTitle);
    }
    out.push('');
    out = out.filter(function(val, i, arr) {
      return !(val === '' && arr[i - 1] === '');
    });
    return out.join('\n');
  };

}).call(this);
