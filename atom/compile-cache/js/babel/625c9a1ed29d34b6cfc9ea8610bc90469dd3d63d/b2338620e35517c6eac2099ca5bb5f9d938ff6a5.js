var moment = require('moment');

/**
 * Parses the git commit revision from blame data for a line of code.
 *
 * @param {string} line - the blame data for a particular line of code
 * @return {string} - the git revision hash string.
 */
function parseRevision(line) {
  var revisionRegex = /^\w+/;
  return line.match(revisionRegex)[0];
}

/**
 * Parses the author name from blame data for a line of code.
 *
 * @param {string} line - the blame data for a particular line of code
 * @return {string} - the author name for that line of code.
 */
function parseAuthor(line) {
  var committerMatcher = /^author\s(.*)$/m;
  return line.match(committerMatcher)[1];
}

/**
 * Parses the committer name from blame data for a line of code.
 *
 * @param {string} line - the blame data for a particular line of code
 * @return {string} - the committer name for that line of code.
 */
function parseCommitter(line) {
  var committerMatcher = /^committer\s(.*)$/m;
  return line.match(committerMatcher)[1];
}

/**
 * Formats a date according to the user's preferred format string.
 * @param {object} date - a moment date object
 */
function formatDate(date) {
  var formatString = atom.config.get('git-blame.dateFormatString');
  return date.format(formatString);
}

/**
 * Parses the author date from blame data for a line of code.
 *
 * @param {string} line - the blame data for a particular line of code
 * @return {string} - human readable date string of the lines author date
 */
function parseAuthorDate(line) {
  var dateMatcher = /^author-time\s(.*)$/m;
  var dateStamp = line.match(dateMatcher)[1];
  return formatDate(moment.unix(dateStamp));
}

/**
 * Parses the commit date from blame data for a line of code.
 *
 * @param {string} line - the blame data for a particular line of code
 * @return {string} - human readable date string of the lines commit date
 */
function parseCommitterDate(line) {
  var dateMatcher = /^committer-time\s(.*)$/m;
  var dateStamp = line.match(dateMatcher)[1];
  return formatDate(moment.unix(dateStamp));
}

/**
 * Parses the summary line from the blame data for a line of code
 *
 * @param {string} line - the blame data for a particular line of code
 * @return {string} - the summary line for the last commit for a line of code
 */
function parseSummary(line) {
  var summaryMatcher = /^summary\s(.*)$/m;
  return line.match(summaryMatcher)[1];
}

/**
 * Parses the blame --porcelain output for a particular line of code into a
 * usable object with properties:
 *
 * commit: the commit revision
 * line: the line number (1 indexed)
 * committer: name of the committer of that line
 * date: the date of the commit
 * summary: the summary of the commit
 *
 * @param {string} blameData - the blame --porcelain output for a line of code
 * @param {number} index - the index that the data appeared in an array of line
 *    line data (0 indexed)
 * @return {object} - an object with properties described above
 */
function parseBlameLine(blameData, index) {
  return markIfNoCommit({
    hash: parseRevision(blameData),
    line: index + 1,
    author: parseAuthor(blameData),
    date: parseAuthorDate(blameData),
    committer: parseCommitter(blameData),
    committerDate: parseCommitterDate(blameData),
    summary: parseSummary(blameData)
  });
}

/**
 * Returns blameData object marked with property noCommit: true if this line
 * has not yet been committed.
 *
 * @param {object} parsedBlame - parsed blame info for a line
 */
function markIfNoCommit(parsedBlame) {
  if (/^0*$/.test(parsedBlame.hash)) {
    parsedBlame.noCommit = true;
  }
  return parsedBlame;
}

/**
 * Parses git-blame output into usable array of info objects.
 *
 * @param {string} blameOutput - output from 'git blame --porcelain <file>'
 */
function parseBlameOutput(blameOut) {
  // Matches new lines only when followed by a line with commit hash info that
  // are followed by autor line. This is the 1st and 2nd line of the blame
  // --porcelain output.
  var singleLineDataSplitRegex = /\n(?=\w+\s(?:\d+\s)+\d+\nauthor)/g;

  // Split the blame output into data for each line and parse out desired
  // data from each into an object.
  return blameOut.split(singleLineDataSplitRegex).map(parseBlameLine);
}

// EXPORTS
module.exports = {
  parseBlame: parseBlameOutput,
  formatDate: formatDate
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL2FuZHJlaS8uYXRvbS9wYWNrYWdlcy9naXQtYmxhbWUvbGliL3V0aWwvYmxhbWVGb3JtYXR0ZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsSUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDOzs7Ozs7OztBQVFqQyxTQUFTLGFBQWEsQ0FBQyxJQUFJLEVBQUU7QUFDM0IsTUFBSSxhQUFhLEdBQUcsTUFBTSxDQUFDO0FBQzNCLFNBQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztDQUNyQzs7Ozs7Ozs7QUFRRCxTQUFTLFdBQVcsQ0FBQyxJQUFJLEVBQUU7QUFDekIsTUFBSSxnQkFBZ0IsR0FBRyxpQkFBaUIsQ0FBQztBQUN6QyxTQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztDQUN4Qzs7Ozs7Ozs7QUFRRCxTQUFTLGNBQWMsQ0FBQyxJQUFJLEVBQUU7QUFDNUIsTUFBSSxnQkFBZ0IsR0FBRyxvQkFBb0IsQ0FBQztBQUM1QyxTQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztDQUN4Qzs7Ozs7O0FBTUQsU0FBUyxVQUFVLENBQUMsSUFBSSxFQUFFO0FBQ3hCLE1BQUksWUFBWSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLDRCQUE0QixDQUFDLENBQUM7QUFDakUsU0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDO0NBQ2xDOzs7Ozs7OztBQVFELFNBQVMsZUFBZSxDQUFDLElBQUksRUFBRTtBQUM3QixNQUFJLFdBQVcsR0FBRyxzQkFBc0IsQ0FBQztBQUN6QyxNQUFJLFNBQVMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzNDLFNBQU8sVUFBVSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztDQUMzQzs7Ozs7Ozs7QUFRRCxTQUFTLGtCQUFrQixDQUFDLElBQUksRUFBRTtBQUNoQyxNQUFJLFdBQVcsR0FBRyx5QkFBeUIsQ0FBQztBQUM1QyxNQUFJLFNBQVMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzNDLFNBQU8sVUFBVSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztDQUMzQzs7Ozs7Ozs7QUFRRCxTQUFTLFlBQVksQ0FBQyxJQUFJLEVBQUU7QUFDMUIsTUFBSSxjQUFjLEdBQUcsa0JBQWtCLENBQUM7QUFDeEMsU0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0NBQ3RDOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCRCxTQUFTLGNBQWMsQ0FBQyxTQUFTLEVBQUUsS0FBSyxFQUFFO0FBQ3hDLFNBQU8sY0FBYyxDQUFDO0FBQ3BCLFFBQUksRUFBRSxhQUFhLENBQUMsU0FBUyxDQUFDO0FBQzlCLFFBQUksRUFBRSxLQUFLLEdBQUcsQ0FBQztBQUNmLFVBQU0sRUFBRSxXQUFXLENBQUMsU0FBUyxDQUFDO0FBQzlCLFFBQUksRUFBRSxlQUFlLENBQUMsU0FBUyxDQUFDO0FBQ2hDLGFBQVMsRUFBRSxjQUFjLENBQUMsU0FBUyxDQUFDO0FBQ3BDLGlCQUFhLEVBQUUsa0JBQWtCLENBQUMsU0FBUyxDQUFDO0FBQzVDLFdBQU8sRUFBRSxZQUFZLENBQUMsU0FBUyxDQUFDO0dBQ2pDLENBQUMsQ0FBQztDQUNKOzs7Ozs7OztBQVFELFNBQVMsY0FBYyxDQUFDLFdBQVcsRUFBRTtBQUNsQyxNQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxFQUFFO0FBQ2pDLGVBQVcsQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO0dBQzdCO0FBQ0QsU0FBTyxXQUFXLENBQUM7Q0FDckI7Ozs7Ozs7QUFPRCxTQUFTLGdCQUFnQixDQUFDLFFBQVEsRUFBRTs7OztBQUlsQyxNQUFJLHdCQUF3QixHQUFHLG1DQUFtQyxDQUFDOzs7O0FBSW5FLFNBQU8sUUFBUSxDQUFDLEtBQUssQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxjQUFjLENBQUMsQ0FBQztDQUNyRTs7O0FBR0QsTUFBTSxDQUFDLE9BQU8sR0FBRztBQUNmLFlBQVUsRUFBRSxnQkFBZ0I7QUFDNUIsWUFBVSxFQUFFLFVBQVU7Q0FDdkIsQ0FBQyIsImZpbGUiOiIvaG9tZS9hbmRyZWkvLmF0b20vcGFja2FnZXMvZ2l0LWJsYW1lL2xpYi91dGlsL2JsYW1lRm9ybWF0dGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50Jyk7XG5cbi8qKlxuICogUGFyc2VzIHRoZSBnaXQgY29tbWl0IHJldmlzaW9uIGZyb20gYmxhbWUgZGF0YSBmb3IgYSBsaW5lIG9mIGNvZGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGxpbmUgLSB0aGUgYmxhbWUgZGF0YSBmb3IgYSBwYXJ0aWN1bGFyIGxpbmUgb2YgY29kZVxuICogQHJldHVybiB7c3RyaW5nfSAtIHRoZSBnaXQgcmV2aXNpb24gaGFzaCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlUmV2aXNpb24obGluZSkge1xuICB2YXIgcmV2aXNpb25SZWdleCA9IC9eXFx3Ky87XG4gIHJldHVybiBsaW5lLm1hdGNoKHJldmlzaW9uUmVnZXgpWzBdO1xufVxuXG4vKipcbiAqIFBhcnNlcyB0aGUgYXV0aG9yIG5hbWUgZnJvbSBibGFtZSBkYXRhIGZvciBhIGxpbmUgb2YgY29kZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbGluZSAtIHRoZSBibGFtZSBkYXRhIGZvciBhIHBhcnRpY3VsYXIgbGluZSBvZiBjb2RlXG4gKiBAcmV0dXJuIHtzdHJpbmd9IC0gdGhlIGF1dGhvciBuYW1lIGZvciB0aGF0IGxpbmUgb2YgY29kZS5cbiAqL1xuZnVuY3Rpb24gcGFyc2VBdXRob3IobGluZSkge1xuICB2YXIgY29tbWl0dGVyTWF0Y2hlciA9IC9eYXV0aG9yXFxzKC4qKSQvbTtcbiAgcmV0dXJuIGxpbmUubWF0Y2goY29tbWl0dGVyTWF0Y2hlcilbMV07XG59XG5cbi8qKlxuICogUGFyc2VzIHRoZSBjb21taXR0ZXIgbmFtZSBmcm9tIGJsYW1lIGRhdGEgZm9yIGEgbGluZSBvZiBjb2RlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBsaW5lIC0gdGhlIGJsYW1lIGRhdGEgZm9yIGEgcGFydGljdWxhciBsaW5lIG9mIGNvZGVcbiAqIEByZXR1cm4ge3N0cmluZ30gLSB0aGUgY29tbWl0dGVyIG5hbWUgZm9yIHRoYXQgbGluZSBvZiBjb2RlLlxuICovXG5mdW5jdGlvbiBwYXJzZUNvbW1pdHRlcihsaW5lKSB7XG4gIHZhciBjb21taXR0ZXJNYXRjaGVyID0gL15jb21taXR0ZXJcXHMoLiopJC9tO1xuICByZXR1cm4gbGluZS5tYXRjaChjb21taXR0ZXJNYXRjaGVyKVsxXTtcbn1cblxuLyoqXG4gKiBGb3JtYXRzIGEgZGF0ZSBhY2NvcmRpbmcgdG8gdGhlIHVzZXIncyBwcmVmZXJyZWQgZm9ybWF0IHN0cmluZy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBkYXRlIC0gYSBtb21lbnQgZGF0ZSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlKSB7XG4gIHZhciBmb3JtYXRTdHJpbmcgPSBhdG9tLmNvbmZpZy5nZXQoJ2dpdC1ibGFtZS5kYXRlRm9ybWF0U3RyaW5nJyk7XG4gIHJldHVybiBkYXRlLmZvcm1hdChmb3JtYXRTdHJpbmcpO1xufVxuXG4vKipcbiAqIFBhcnNlcyB0aGUgYXV0aG9yIGRhdGUgZnJvbSBibGFtZSBkYXRhIGZvciBhIGxpbmUgb2YgY29kZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbGluZSAtIHRoZSBibGFtZSBkYXRhIGZvciBhIHBhcnRpY3VsYXIgbGluZSBvZiBjb2RlXG4gKiBAcmV0dXJuIHtzdHJpbmd9IC0gaHVtYW4gcmVhZGFibGUgZGF0ZSBzdHJpbmcgb2YgdGhlIGxpbmVzIGF1dGhvciBkYXRlXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQXV0aG9yRGF0ZShsaW5lKSB7XG4gIHZhciBkYXRlTWF0Y2hlciA9IC9eYXV0aG9yLXRpbWVcXHMoLiopJC9tO1xuICB2YXIgZGF0ZVN0YW1wID0gbGluZS5tYXRjaChkYXRlTWF0Y2hlcilbMV07XG4gIHJldHVybiBmb3JtYXREYXRlKG1vbWVudC51bml4KGRhdGVTdGFtcCkpO1xufVxuXG4vKipcbiAqIFBhcnNlcyB0aGUgY29tbWl0IGRhdGUgZnJvbSBibGFtZSBkYXRhIGZvciBhIGxpbmUgb2YgY29kZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbGluZSAtIHRoZSBibGFtZSBkYXRhIGZvciBhIHBhcnRpY3VsYXIgbGluZSBvZiBjb2RlXG4gKiBAcmV0dXJuIHtzdHJpbmd9IC0gaHVtYW4gcmVhZGFibGUgZGF0ZSBzdHJpbmcgb2YgdGhlIGxpbmVzIGNvbW1pdCBkYXRlXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQ29tbWl0dGVyRGF0ZShsaW5lKSB7XG4gIHZhciBkYXRlTWF0Y2hlciA9IC9eY29tbWl0dGVyLXRpbWVcXHMoLiopJC9tO1xuICB2YXIgZGF0ZVN0YW1wID0gbGluZS5tYXRjaChkYXRlTWF0Y2hlcilbMV07XG4gIHJldHVybiBmb3JtYXREYXRlKG1vbWVudC51bml4KGRhdGVTdGFtcCkpO1xufVxuXG4vKipcbiAqIFBhcnNlcyB0aGUgc3VtbWFyeSBsaW5lIGZyb20gdGhlIGJsYW1lIGRhdGEgZm9yIGEgbGluZSBvZiBjb2RlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGxpbmUgLSB0aGUgYmxhbWUgZGF0YSBmb3IgYSBwYXJ0aWN1bGFyIGxpbmUgb2YgY29kZVxuICogQHJldHVybiB7c3RyaW5nfSAtIHRoZSBzdW1tYXJ5IGxpbmUgZm9yIHRoZSBsYXN0IGNvbW1pdCBmb3IgYSBsaW5lIG9mIGNvZGVcbiAqL1xuZnVuY3Rpb24gcGFyc2VTdW1tYXJ5KGxpbmUpIHtcbiAgdmFyIHN1bW1hcnlNYXRjaGVyID0gL15zdW1tYXJ5XFxzKC4qKSQvbTtcbiAgcmV0dXJuIGxpbmUubWF0Y2goc3VtbWFyeU1hdGNoZXIpWzFdO1xufVxuXG4vKipcbiAqIFBhcnNlcyB0aGUgYmxhbWUgLS1wb3JjZWxhaW4gb3V0cHV0IGZvciBhIHBhcnRpY3VsYXIgbGluZSBvZiBjb2RlIGludG8gYVxuICogdXNhYmxlIG9iamVjdCB3aXRoIHByb3BlcnRpZXM6XG4gKlxuICogY29tbWl0OiB0aGUgY29tbWl0IHJldmlzaW9uXG4gKiBsaW5lOiB0aGUgbGluZSBudW1iZXIgKDEgaW5kZXhlZClcbiAqIGNvbW1pdHRlcjogbmFtZSBvZiB0aGUgY29tbWl0dGVyIG9mIHRoYXQgbGluZVxuICogZGF0ZTogdGhlIGRhdGUgb2YgdGhlIGNvbW1pdFxuICogc3VtbWFyeTogdGhlIHN1bW1hcnkgb2YgdGhlIGNvbW1pdFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBibGFtZURhdGEgLSB0aGUgYmxhbWUgLS1wb3JjZWxhaW4gb3V0cHV0IGZvciBhIGxpbmUgb2YgY29kZVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gdGhlIGluZGV4IHRoYXQgdGhlIGRhdGEgYXBwZWFyZWQgaW4gYW4gYXJyYXkgb2YgbGluZVxuICogICAgbGluZSBkYXRhICgwIGluZGV4ZWQpXG4gKiBAcmV0dXJuIHtvYmplY3R9IC0gYW4gb2JqZWN0IHdpdGggcHJvcGVydGllcyBkZXNjcmliZWQgYWJvdmVcbiAqL1xuZnVuY3Rpb24gcGFyc2VCbGFtZUxpbmUoYmxhbWVEYXRhLCBpbmRleCkge1xuICByZXR1cm4gbWFya0lmTm9Db21taXQoe1xuICAgIGhhc2g6IHBhcnNlUmV2aXNpb24oYmxhbWVEYXRhKSxcbiAgICBsaW5lOiBpbmRleCArIDEsXG4gICAgYXV0aG9yOiBwYXJzZUF1dGhvcihibGFtZURhdGEpLFxuICAgIGRhdGU6IHBhcnNlQXV0aG9yRGF0ZShibGFtZURhdGEpLFxuICAgIGNvbW1pdHRlcjogcGFyc2VDb21taXR0ZXIoYmxhbWVEYXRhKSxcbiAgICBjb21taXR0ZXJEYXRlOiBwYXJzZUNvbW1pdHRlckRhdGUoYmxhbWVEYXRhKSxcbiAgICBzdW1tYXJ5OiBwYXJzZVN1bW1hcnkoYmxhbWVEYXRhKVxuICB9KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGJsYW1lRGF0YSBvYmplY3QgbWFya2VkIHdpdGggcHJvcGVydHkgbm9Db21taXQ6IHRydWUgaWYgdGhpcyBsaW5lXG4gKiBoYXMgbm90IHlldCBiZWVuIGNvbW1pdHRlZC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyc2VkQmxhbWUgLSBwYXJzZWQgYmxhbWUgaW5mbyBmb3IgYSBsaW5lXG4gKi9cbmZ1bmN0aW9uIG1hcmtJZk5vQ29tbWl0KHBhcnNlZEJsYW1lKSB7XG4gICBpZiAoL14wKiQvLnRlc3QocGFyc2VkQmxhbWUuaGFzaCkpIHtcbiAgICAgcGFyc2VkQmxhbWUubm9Db21taXQgPSB0cnVlO1xuICAgfVxuICAgcmV0dXJuIHBhcnNlZEJsYW1lO1xufVxuXG4vKipcbiAqIFBhcnNlcyBnaXQtYmxhbWUgb3V0cHV0IGludG8gdXNhYmxlIGFycmF5IG9mIGluZm8gb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmxhbWVPdXRwdXQgLSBvdXRwdXQgZnJvbSAnZ2l0IGJsYW1lIC0tcG9yY2VsYWluIDxmaWxlPidcbiAqL1xuZnVuY3Rpb24gcGFyc2VCbGFtZU91dHB1dChibGFtZU91dCkge1xuICAvLyBNYXRjaGVzIG5ldyBsaW5lcyBvbmx5IHdoZW4gZm9sbG93ZWQgYnkgYSBsaW5lIHdpdGggY29tbWl0IGhhc2ggaW5mbyB0aGF0XG4gIC8vIGFyZSBmb2xsb3dlZCBieSBhdXRvciBsaW5lLiBUaGlzIGlzIHRoZSAxc3QgYW5kIDJuZCBsaW5lIG9mIHRoZSBibGFtZVxuICAvLyAtLXBvcmNlbGFpbiBvdXRwdXQuXG4gIHZhciBzaW5nbGVMaW5lRGF0YVNwbGl0UmVnZXggPSAvXFxuKD89XFx3K1xccyg/OlxcZCtcXHMpK1xcZCtcXG5hdXRob3IpL2c7XG5cbiAgLy8gU3BsaXQgdGhlIGJsYW1lIG91dHB1dCBpbnRvIGRhdGEgZm9yIGVhY2ggbGluZSBhbmQgcGFyc2Ugb3V0IGRlc2lyZWRcbiAgLy8gZGF0YSBmcm9tIGVhY2ggaW50byBhbiBvYmplY3QuXG4gIHJldHVybiBibGFtZU91dC5zcGxpdChzaW5nbGVMaW5lRGF0YVNwbGl0UmVnZXgpLm1hcChwYXJzZUJsYW1lTGluZSk7XG59XG5cbi8vIEVYUE9SVFNcbm1vZHVsZS5leHBvcnRzID0ge1xuICBwYXJzZUJsYW1lOiBwYXJzZUJsYW1lT3V0cHV0LFxuICBmb3JtYXREYXRlOiBmb3JtYXREYXRlXG59O1xuIl19