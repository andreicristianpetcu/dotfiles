var _ = require('underscore');
var BlameErrorView = require('../views/blame-error-view');
var strings = require('../locales/strings');

/**
 * A mapping from git error message fragment to the strings error key. When an
 * error is thrown by the blamer, we try to match the errors message to something
 * in this map to decide which message to show the user.
 */
var gitErrorMessageMap = {
  'no such path': 'error-file-path-not-checked-in'
};

/**
 * Shows an error to the user with the given message.
 *
 * @param {String} errorMessage - Error message to show the user
 */
function showError(errorMessageKey) {
  var messageString = strings[errorMessageKey];

  if (messageString) {
    var errorView = new BlameErrorView({ message: messageString });
    errorView.attach();
  }
}

/**
 * Handles an error by decoding the message into one to show the user, or just swallowing it.
 *
 * @param {Error} error - The error to be handled.
 */
function handleError(error) {
  var gitErrorKey = _.find(_.keys(gitErrorMessageMap), function (gitErrorFragment) {
    var regex = new RegExp(gitErrorFragment);
    return regex.test(error.message);
  });

  var userMessageKey = gitErrorKey ? gitErrorMessageMap[gitErrorKey] : '';
  if (userMessageKey) {
    // Show the user an error if there is a matching key...
    showError(userMessageKey);
  }
}

// EXPORTS
module.exports = {
  handleError: handleError,
  showError: showError
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL2FuZHJlaS8uYXRvbS9wYWNrYWdlcy9naXQtYmxhbWUvbGliL2NvbnRyb2xsZXJzL2Vycm9yQ29udHJvbGxlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxJQUFNLENBQUMsR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUM7QUFDaEMsSUFBTSxjQUFjLEdBQUcsT0FBTyxDQUFDLDJCQUEyQixDQUFDLENBQUM7QUFDNUQsSUFBTSxPQUFPLEdBQUcsT0FBTyxDQUFDLG9CQUFvQixDQUFDLENBQUM7Ozs7Ozs7QUFPOUMsSUFBSSxrQkFBa0IsR0FBRztBQUN2QixnQkFBYyxFQUFFLGdDQUFnQztDQUNqRCxDQUFDOzs7Ozs7O0FBT0YsU0FBUyxTQUFTLENBQUMsZUFBZSxFQUFFO0FBQ2xDLE1BQUksYUFBYSxHQUFHLE9BQU8sQ0FBQyxlQUFlLENBQUMsQ0FBQzs7QUFFN0MsTUFBSSxhQUFhLEVBQUU7QUFDakIsUUFBSSxTQUFTLEdBQUcsSUFBSSxjQUFjLENBQUMsRUFBQyxPQUFPLEVBQUUsYUFBYSxFQUFDLENBQUMsQ0FBQztBQUM3RCxhQUFTLENBQUMsTUFBTSxFQUFFLENBQUM7R0FDcEI7Q0FFRjs7Ozs7OztBQU9ELFNBQVMsV0FBVyxDQUFDLEtBQUssRUFBRTtBQUMxQixNQUFJLFdBQVcsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsRUFBRSxVQUFTLGdCQUFnQixFQUFFO0FBQzlFLFFBQUksS0FBSyxHQUFHLElBQUksTUFBTSxDQUFDLGdCQUFnQixDQUFDLENBQUM7QUFDekMsV0FBTyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztHQUNsQyxDQUFDLENBQUM7O0FBRUgsTUFBSSxjQUFjLEdBQUcsV0FBVyxHQUFHLGtCQUFrQixDQUFDLFdBQVcsQ0FBQyxHQUFHLEVBQUUsQ0FBQztBQUN4RSxNQUFJLGNBQWMsRUFBRTs7QUFFbEIsYUFBUyxDQUFDLGNBQWMsQ0FBQyxDQUFDO0dBQzNCO0NBQ0Y7OztBQUdELE1BQU0sQ0FBQyxPQUFPLEdBQUc7QUFDZixhQUFXLEVBQUUsV0FBVztBQUN4QixXQUFTLEVBQUUsU0FBUztDQUNyQixDQUFDIiwiZmlsZSI6Ii9ob21lL2FuZHJlaS8uYXRvbS9wYWNrYWdlcy9naXQtYmxhbWUvbGliL2NvbnRyb2xsZXJzL2Vycm9yQ29udHJvbGxlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5jb25zdCBCbGFtZUVycm9yVmlldyA9IHJlcXVpcmUoJy4uL3ZpZXdzL2JsYW1lLWVycm9yLXZpZXcnKTtcbmNvbnN0IHN0cmluZ3MgPSByZXF1aXJlKCcuLi9sb2NhbGVzL3N0cmluZ3MnKTtcblxuLyoqXG4gKiBBIG1hcHBpbmcgZnJvbSBnaXQgZXJyb3IgbWVzc2FnZSBmcmFnbWVudCB0byB0aGUgc3RyaW5ncyBlcnJvciBrZXkuIFdoZW4gYW5cbiAqIGVycm9yIGlzIHRocm93biBieSB0aGUgYmxhbWVyLCB3ZSB0cnkgdG8gbWF0Y2ggdGhlIGVycm9ycyBtZXNzYWdlIHRvIHNvbWV0aGluZ1xuICogaW4gdGhpcyBtYXAgdG8gZGVjaWRlIHdoaWNoIG1lc3NhZ2UgdG8gc2hvdyB0aGUgdXNlci5cbiAqL1xudmFyIGdpdEVycm9yTWVzc2FnZU1hcCA9IHtcbiAgJ25vIHN1Y2ggcGF0aCc6ICdlcnJvci1maWxlLXBhdGgtbm90LWNoZWNrZWQtaW4nXG59O1xuXG4vKipcbiAqIFNob3dzIGFuIGVycm9yIHRvIHRoZSB1c2VyIHdpdGggdGhlIGdpdmVuIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGVycm9yTWVzc2FnZSAtIEVycm9yIG1lc3NhZ2UgdG8gc2hvdyB0aGUgdXNlclxuICovXG5mdW5jdGlvbiBzaG93RXJyb3IoZXJyb3JNZXNzYWdlS2V5KSB7XG4gIHZhciBtZXNzYWdlU3RyaW5nID0gc3RyaW5nc1tlcnJvck1lc3NhZ2VLZXldO1xuXG4gIGlmIChtZXNzYWdlU3RyaW5nKSB7XG4gICAgdmFyIGVycm9yVmlldyA9IG5ldyBCbGFtZUVycm9yVmlldyh7bWVzc2FnZTogbWVzc2FnZVN0cmluZ30pO1xuICAgIGVycm9yVmlldy5hdHRhY2goKTtcbiAgfVxuXG59XG5cbi8qKlxuICogSGFuZGxlcyBhbiBlcnJvciBieSBkZWNvZGluZyB0aGUgbWVzc2FnZSBpbnRvIG9uZSB0byBzaG93IHRoZSB1c2VyLCBvciBqdXN0IHN3YWxsb3dpbmcgaXQuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3IgLSBUaGUgZXJyb3IgdG8gYmUgaGFuZGxlZC5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlRXJyb3IoZXJyb3IpIHtcbiAgdmFyIGdpdEVycm9yS2V5ID0gXy5maW5kKF8ua2V5cyhnaXRFcnJvck1lc3NhZ2VNYXApLCBmdW5jdGlvbihnaXRFcnJvckZyYWdtZW50KSB7XG4gICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cChnaXRFcnJvckZyYWdtZW50KTtcbiAgICByZXR1cm4gcmVnZXgudGVzdChlcnJvci5tZXNzYWdlKTtcbiAgfSk7XG5cbiAgdmFyIHVzZXJNZXNzYWdlS2V5ID0gZ2l0RXJyb3JLZXkgPyBnaXRFcnJvck1lc3NhZ2VNYXBbZ2l0RXJyb3JLZXldIDogJyc7XG4gIGlmICh1c2VyTWVzc2FnZUtleSkge1xuICAgIC8vIFNob3cgdGhlIHVzZXIgYW4gZXJyb3IgaWYgdGhlcmUgaXMgYSBtYXRjaGluZyBrZXkuLi5cbiAgICBzaG93RXJyb3IodXNlck1lc3NhZ2VLZXkpO1xuICB9XG59XG5cbi8vIEVYUE9SVFNcbm1vZHVsZS5leHBvcnRzID0ge1xuICBoYW5kbGVFcnJvcjogaGFuZGxlRXJyb3IsXG4gIHNob3dFcnJvcjogc2hvd0Vycm9yXG59O1xuIl19