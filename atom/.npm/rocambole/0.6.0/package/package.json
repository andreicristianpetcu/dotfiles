{"name":"rocambole","version":"0.6.0","description":"Recursively walk and transform EcmaScript AST","main":"rocambole.js","directories":{"test":"test"},"scripts":{"test":"istanbul test test/runner.js"},"repository":{"type":"git","url":"https://github.com/millermedeiros/rocambole.git"},"bugs":{"url":"https://github.com/millermedeiros/rocambole/issues"},"keywords":["ast","walk","syntax","source","tree","traversal","falafel","burrito","esprima"],"author":{"name":"Miller Medeiros","email":"http://blog.millermedeiros.com"},"license":"MIT","dependencies":{"esprima":"^2.0"},"devDependencies":{"mocha":"~1.7","expect.js":"0.2","istanbul":"~0.1.23"},"readme":"# Rocambole [![Build Status](https://secure.travis-ci.org/millermedeiros/rocambole.svg?branch=master)](https://travis-ci.org/millermedeiros/rocambole)\n\n![rocambole](https://raw.github.com/millermedeiros/rocambole/master/rocambole.jpg)\n\nRecursively walk and add extra information/helpers to [Esprima / Mozilla\nSpiderMonkey Parser API](http://esprima.org/doc/index.html#ast) compatible AST.\n\nThe main difference between other tools is that it also keeps information about\ntokens and white spaces and it is meant to be used to transform the tokens and\nnot the string values itself.\n\nThis library is specially useful for non-destructive AST manipulation.\n\n\n## Inspiration\n\nThis module was heavily inspired by\n[node-falafel](https://github.com/substack/node-falafel) and\n[node-burrito](https://github.com/substack/node-burrito) but I needed more\ninformation than what is currently available on falafel (specially about\ntokens, empty lines and white spaces) and also needed to do the node traversing\non the opposite order (start from leaf nodes). The amount of changes required\nto introduce the new features and the differences on the concept behind the\ntool justified a new project.\n\nIt was created mainly to be used on\n[esformatter](https://github.com/millermedeiros/esformatter/).\n\n\n\n## Extra Tokens\n\nBesides all the regular tokens returned by `esprima` we also add a few more\nthat are important for non-destructive transformations:\n\n * `WhiteSpace`\n   - Can store multiple white spaces (tabs are considered white space, line\n     breaks not). Important if you want to do non-destructive replacements that\n     are white-space sensitive.\n   - Multiple subsequent white spaces are treated as a single token.\n * `LineBreak`\n * `LineComment`\n * `BlockComment`\n\nIt's way easier to rebuild the JS string if the tokens already have line breaks\nand comments. It's also easier to identify if previous/next/current token is a\nLineBreak or Comment (sometimes needed for non-destructive transformations).\n\nRocambole structure might change in the future to keep the extraneous tokens\noutside the `tokens` array and also add an option to toggle the behavior.\n([issue #7](https://github.com/millermedeiros/rocambole/issues/7))\n\n\n## Extra Properties\n\nEach Node have the following extra properties/methods:\n\n  - `parent` : Node|undefined\n  - `toString()` : string\n  - `next` : Node|undefined\n  - `prev` : Node|undefined\n  - `depth` : Number\n  - `startToken` : Token\n  - `endToken` : Token\n\nEach token also have:\n\n - `prev` : Token|undefined\n - `next` : Token|undefined\n\nBlockComment also have:\n\n  - `originalIndent`: String|undefined\n\nTo get a better idea of the generated AST structure try out\n[rocambole-visualize](http://piuccio.github.io/rocambole-visualize/).\n\n\n## Linked List\n\nYou should **treat the tokens as a linked list instead of reading the\n`ast.tokens` array** (inserting/removing items from a linked list is very cheap\nand won't break the loop). You should grab a reference to the `node.startToken`\nand get `token.next` until you find the desired token or reach the end of the\nprogram. To loop between all tokens inside a node you can do like this:\n\n```js\nvar token = node.startToken;\nwhile (token !== node.endToken.next) {\n    doStuffWithToken(token);\n    token = token.next;\n}\n```\n\nThe method `toString` loops through all tokens between `node.startToken` and\n`node.endToken` grabbing the `token.raw` (used by comments) or `token.value`\nproperties. To implement a method similar to falafel `update()` you can do\nthis:\n\n```js\nfunction update(node, str){\n    var newToken = {\n        type : 'Custom', // can be anything (not used internally)\n        value : str\n    };\n    // update linked list references\n    if ( node.startToken.prev ) {\n        node.startToken.prev.next = newToken;\n        newToken.prev = node.startToken.prev;\n    }\n    if ( node.endToken.next ) {\n        node.endToken.next.prev = newToken;\n        newToken.next = node.endToken.next;\n    }\n    node.startToken = node.endToken = newToken;\n}\n```\n\n\n## Helpers\n\nI plan to create helpers as separate projects when possible.\n\n - [rocambole-token](https://github.com/millermedeiros/rocambole-token): helpers for token manipulation/traversal\n - [rocambole-node](https://github.com/millermedeiros/rocambole-node): helpers for node manipulation/traversal\n - [rocambole-whitespace](https://github.com/millermedeiros/rocambole-whitespace): helpers for whitespace manipulation\n - [rocambole-linebreak](https://github.com/millermedeiros/rocambole-linebreak): helpers for line break manipulation\n - [rocambole-indent](https://github.com/millermedeiros/rocambole-indent): helpers for indentation\n\n\n## API\n\n\n### rocambole.parse(source, [opts])\n\nParses a string and instrument the AST with extra properties/methods.\n\n```js\nvar rocambole = require('rocambole');\nvar ast = rocambole.parse(string);\nconsole.log( ast.startToken );\n// to get a string representation of all tokens call toString()\nconsole.log( ast.toString() );\n```\n\nYou can pass custom options as the second argument:\n\n```js\nrocambole.parse(source, {\n    loc: true,\n    // custom options are forwarded to the rocambole.parseFn\n    ecmaFeatures: {\n        arrowFunctions: true\n    }\n});\n```\n\n**IMPORTANT:** rocambole needs the `range`, `tokens` and `comment` info to\nbuild the token linked list, so these options will always be set to `true`.\n\n### rocambole.parseFn:Function\n\nAllows you to override the function used to parse the program. Defaults to\n`esprima.parse`.\n\n```js\n// espree is compatible with esprima AST so things should work as expected\nvar espree = require('espree');\nrocambole.parseFn = espree.parse;\nrocambole.parseContext = espree;\n```\n\n### rocambole.parseContext:Object\n\nSets the context (`this` value) of the `parseFn`. Defaults to `esprima`.\n\n### rocambole.parseOptions:Object\n\nSets the default options passed to `parseFn`.\n\n```js\n// default values\nrocambole.parseOptions = {\n    // we need range/tokens/comment info to build the tokens linked list!\n    range: true,\n    tokens: true,\n    comment: true\n};\n```\n\n### rocambole.moonwalk(ast, callback)\n\nThe `moonwalk()` starts at the leaf nodes and go down the tree until it reaches\nthe root node (`Program`). Each node will be traversed only once.\n\n```js\nrocambole.moonwalk(ast, function(node){\n    if (node.type == 'ArrayExpression'){\n        console.log( node.depth +': '+ node.toString() );\n    }\n});\n```\n\nTraverse order:\n\n```\n Program [#18]\n `-FunctionDeclaration [#16]\n   |-BlockStatement [#14]\n   | |-IfStatement [#12]\n   | | |-BynaryExpression [#9]\n   | | | |-Identifier [#4]\n   | | | `-Literal [#5]\n   | | `-BlockStatement [#10]\n   | |   `-ExpressionStatement [#6]\n   | |     `-AssignmentExpression [#3]\n   | |       |-Identifier [#1 walk starts here]\n   | |       `-Literal [#2]\n   | `-VariableDeclaration [#13]\n   |   `-VariableDeclarator [#11]\n   |     |-Identifier [#7]\n   |     `-Literal [#8]\n   `-ReturnStatement [#17]\n     `-Identifier [#15]\n```\n\nThis behavior is very different from node-falafel and node-burrito.\n\n\n### rocambole.walk(ast, callback)\n\nIt loops through all nodes on the AST starting from the root node (`Program`),\nsimilar to `node-falafel`.\n\n```js\nrocambole.walk(ast, function(node){\n    console.log(node.type);\n});\n```\n\n\n## Popular Alternatives\n\n - [burrito](https://github.com/substack/node-burrito)\n - [falafel](https://github.com/substack/node-falafel)\n\n\n\n## Unit Tests\n\nBesides the regular unit tests we also use\n[istanbul](https://github.com/yahoo/istanbul) to generate code coverage\nreports, tests should have at least 95% code coverage for statements, branches\nand lines and 100% code coverage for functions or travis build will fail.\n\nWe do not run the coverage test at each call since it slows down the\nperformnace of the tests and it also makes it harder to see the test results.\nTo execute tests and generate coverage report call `npm test --coverage`, for\nregular tests just do `npm test`.\n\nCoverage reports are not committed to the repository since they will change at\neach `npm test --coverage` call.\n\n\n\n## License\n\nMIT\n\n","readmeFilename":"README.md","homepage":"https://github.com/millermedeiros/rocambole","_id":"rocambole@0.6.0","_shasum":"534f235a287cc17f9b057b95bd11d0f0dc35452c","_resolved":"https://registry.npmjs.org/rocambole/-/rocambole-0.6.0.tgz","_from":"https://registry.npmjs.org/rocambole/-/rocambole-0.6.0.tgz"}